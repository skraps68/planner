name: Manual Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Docker image tag to deploy (leave empty for latest)'
        required: false
        type: string
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        type: boolean
        default: false
      force_deployment:
        description: 'Force new deployment even if no changes'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: planner-app
  K8S_NAMESPACE: planner-app
  DEPLOYMENT_NAME: planner-app

jobs:
  manual-deploy:
    name: Manual Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set environment variables
        id: env-vars
        run: |
          if [ "${{ inputs.environment }}" == "production" ]; then
            echo "EKS_CLUSTER_NAME=planner-production-cluster" >> $GITHUB_OUTPUT
            echo "DB_HOST=${{ secrets.PRODUCTION_DB_HOST }}" >> $GITHUB_OUTPUT
            echo "DB_PORT=${{ secrets.PRODUCTION_DB_PORT }}" >> $GITHUB_OUTPUT
            echo "DB_NAME=${{ secrets.PRODUCTION_DB_NAME }}" >> $GITHUB_OUTPUT
            echo "DB_USER=${{ secrets.PRODUCTION_DB_USER }}" >> $GITHUB_OUTPUT
            echo "DB_PASSWORD=${{ secrets.PRODUCTION_DB_PASSWORD }}" >> $GITHUB_OUTPUT
            echo "REDIS_HOST=${{ secrets.PRODUCTION_REDIS_HOST }}" >> $GITHUB_OUTPUT
            echo "REDIS_PORT=${{ secrets.PRODUCTION_REDIS_PORT }}" >> $GITHUB_OUTPUT
            echo "SECRET_KEY=${{ secrets.PRODUCTION_SECRET_KEY }}" >> $GITHUB_OUTPUT
            echo "APP_POD_ROLE_ARN=${{ secrets.PRODUCTION_APP_POD_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "CERTIFICATE_ARN=${{ secrets.PRODUCTION_CERTIFICATE_ARN }}" >> $GITHUB_OUTPUT
            echo "DOMAIN_NAME=${{ secrets.PRODUCTION_DOMAIN_NAME }}" >> $GITHUB_OUTPUT
          else
            echo "EKS_CLUSTER_NAME=planner-staging-cluster" >> $GITHUB_OUTPUT
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_OUTPUT
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT }}" >> $GITHUB_OUTPUT
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_OUTPUT
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_OUTPUT
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_OUTPUT
            echo "REDIS_HOST=${{ secrets.STAGING_REDIS_HOST }}" >> $GITHUB_OUTPUT
            echo "REDIS_PORT=${{ secrets.STAGING_REDIS_PORT }}" >> $GITHUB_OUTPUT
            echo "SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}" >> $GITHUB_OUTPUT
            echo "APP_POD_ROLE_ARN=${{ secrets.STAGING_APP_POD_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "CERTIFICATE_ARN=${{ secrets.STAGING_CERTIFICATE_ARN }}" >> $GITHUB_OUTPUT
            echo "DOMAIN_NAME=${{ secrets.STAGING_DOMAIN_NAME }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Determine image tag
        id: image-tag
        run: |
          if [ -n "${{ inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ inputs.image_tag }}"
          else
            IMAGE_TAG="${{ inputs.environment }}-latest"
          fi
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
      
      - name: Build and push image (if no tag specified)
        if: inputs.image_tag == ''
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --target production \
            --build-arg ENVIRONMENT=${{ inputs.environment }} \
            .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:${{ inputs.environment }}-latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:${{ inputs.environment }}-latest
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ steps.env-vars.outputs.EKS_CLUSTER_NAME }}
          
          # Verify connection
          kubectl cluster-info
          kubectl get nodes
      
      - name: Create database backup (production only)
        if: inputs.environment == 'production' && !inputs.skip_migrations
        run: |
          echo "Creating database backup..."
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          aws rds create-db-snapshot \
            --db-instance-identifier planner-production-db \
            --db-snapshot-identifier planner-manual-backup-$TIMESTAMP
          
          echo "Backup initiated: planner-manual-backup-$TIMESTAMP"
          echo "Note: Backup is running in background"
      
      - name: Run database migrations
        if: ${{ !inputs.skip_migrations }}
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
          TIMESTAMP: ${{ github.sha }}
        run: |
          # Set environment variables for manifest substitution
          export ECR_REPOSITORY=${{ env.ECR_REPOSITORY }}
          export ENVIRONMENT=${{ inputs.environment }}
          export DB_HOST=${{ steps.env-vars.outputs.DB_HOST }}
          export DB_PORT=${{ steps.env-vars.outputs.DB_PORT }}
          export DB_NAME=${{ steps.env-vars.outputs.DB_NAME }}
          export DB_USER=${{ steps.env-vars.outputs.DB_USER }}
          
          # Apply migration job
          envsubst < infrastructure/kubernetes/job-migration.yaml | kubectl apply -f -
          
          # Wait for job to complete
          JOB_NAME="planner-migration-${TIMESTAMP}"
          kubectl wait --for=condition=complete --timeout=600s job/${JOB_NAME} -n ${{ env.K8S_NAMESPACE }} || {
            echo "‚ùå Migration job failed or timed out"
            kubectl logs -n ${{ env.K8S_NAMESPACE }} job/${JOB_NAME}
            exit 1
          }
          
          echo "‚úÖ Migration completed successfully"
      
      - name: Update Kubernetes secrets
        run: |
          # Update secrets
          kubectl create secret generic planner-secrets \
            --from-literal=db-password="${{ steps.env-vars.outputs.DB_PASSWORD }}" \
            --from-literal=secret-key="${{ steps.env-vars.outputs.SECRET_KEY }}" \
            -n ${{ env.K8S_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy to EKS
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          # Set environment variables for manifest substitution
          export ECR_REPOSITORY=${{ env.ECR_REPOSITORY }}
          export ENVIRONMENT=${{ inputs.environment }}
          export DB_HOST=${{ steps.env-vars.outputs.DB_HOST }}
          export DB_PORT=${{ steps.env-vars.outputs.DB_PORT }}
          export DB_NAME=${{ steps.env-vars.outputs.DB_NAME }}
          export DB_USER=${{ steps.env-vars.outputs.DB_USER }}
          export REDIS_HOST=${{ steps.env-vars.outputs.REDIS_HOST }}
          export REDIS_PORT=${{ steps.env-vars.outputs.REDIS_PORT }}
          export APP_POD_ROLE_ARN=${{ steps.env-vars.outputs.APP_POD_ROLE_ARN }}
          
          # Apply Kubernetes manifests
          kubectl apply -f infrastructure/kubernetes/namespace.yaml
          envsubst < infrastructure/kubernetes/serviceaccount.yaml | kubectl apply -f -
          envsubst < infrastructure/kubernetes/deployment.yaml | kubectl apply -f -
          kubectl apply -f infrastructure/kubernetes/service.yaml
          
          # Apply ingress if certificate ARN is provided
          if [ -n "${{ steps.env-vars.outputs.CERTIFICATE_ARN }}" ]; then
            export CERTIFICATE_ARN=${{ steps.env-vars.outputs.CERTIFICATE_ARN }}
            export DOMAIN_NAME=${{ steps.env-vars.outputs.DOMAIN_NAME }}
            envsubst < infrastructure/kubernetes/ingress.yaml | kubectl apply -f -
          fi
          
          # Apply HPA
          kubectl apply -f infrastructure/kubernetes/hpa.yaml
          
          # Force restart if requested
          if [ "${{ inputs.force_deployment }}" == "true" ]; then
            kubectl rollout restart deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }}
          fi
          
          # Wait for rollout to complete
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }} --timeout=600s
      
      - name: Verify deployment
        run: |
          # Check pod status
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}
          
          # Check deployment status
          kubectl get deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }}
          
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod -l app=planner -n ${{ env.K8S_NAMESPACE }} --timeout=300s
          
          # Check health endpoint (if domain is configured)
          if [ -n "${{ steps.env-vars.outputs.DOMAIN_NAME }}" ]; then
            sleep 30
            curl -f https://${{ steps.env-vars.outputs.DOMAIN_NAME }}/health || echo "Health check failed, but continuing..."
          fi
          
          echo "‚úÖ Deployment successful! Service is healthy."
      
      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ steps.image-tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Migrations**: ${{ inputs.skip_migrations && 'Skipped' || 'Executed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Force Deployment**: ${{ inputs.force_deployment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: ${{ steps.env-vars.outputs.EKS_CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ env.K8S_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
      
      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ö†Ô∏è Deployment failed. Initiating rollback..."
          
          # Rollback deployment
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }}
          
          # Wait for rollback to complete
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }} --timeout=300s
          
          echo "üîÑ Rollback completed"
          
          # Show current status
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}
